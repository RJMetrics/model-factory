// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  describe('Model Factory', function() {
    var angularCache, httpBackend, modelFactory, modelList, modelUrl, rootScope, url;
    modelList = [
      {
        id: 1,
        name: "model1"
      }, {
        id: 2,
        name: "model2"
      }, {
        id: 3,
        name: "model3"
      }
    ];
    modelUrl = "test.com/model";
    modelFactory = null;
    httpBackend = null;
    angularCache = null;
    url = null;
    rootScope = null;
    beforeEach(function() {
      return module('rjmetrics.model-factory');
    });
    beforeEach(inject(function(_modelFactory_, _$httpBackend_, $angularCacheFactory, $q, $rootScope) {
      modelFactory = _modelFactory_;
      httpBackend = _$httpBackend_;
      angularCache = $angularCacheFactory;
      return rootScope = $rootScope;
    }));
    afterEach(function() {
      angularCache.get(modelUrl).destroy();
      return httpBackend.verifyNoOutstandingRequest();
    });
    it("instantiats a model correctly", function() {
      var Model, model;
      Model = modelFactory(modelUrl);
      expect(Model.url).toBe(modelUrl);
      expect(Model.get).toBeDefined();
      expect(Model.getCollection).toBeDefined();
      expect(Model.save).toBeDefined();
      expect(Model.create).toBeDefined();
      expect(Model["delete"]).toBeDefined();
      expect(angularCache.get(modelUrl)).toBeDefined();
      expect(Model.prototype.$get).toBeDefined();
      expect(Model.prototype.$save).toBeDefined();
      expect(Model.prototype.$delete).toBeDefined();
      model = new Model();
      return expect(model instanceof Model).toBeTruthy();
    });
    it("gets a model and stores it in the cache", function() {
      var Model, aModel, aModel2, key, value;
      httpBackend.expectGET(new RegExp("" + modelUrl + "/1")).respond(200, modelList[0]);
      Model = modelFactory(modelUrl);
      aModel = null;
      Model.get(1).then(function(m) {
        return aModel = m;
      });
      httpBackend.flush();
      expect(aModel instanceof Model).toBeTruthy();
      for (key in aModel) {
        value = aModel[key];
        if (!angular.isFunction(value)) {
          expect(value).toBe(modelList[0][key]);
          expect(angularCache.get(modelUrl).get("" + aModel.id)[key]).toBe(modelList[0][key]);
        }
      }
      aModel2 = null;
      aModel.$get().then(function(m) {
        return aModel2 = m;
      });
      rootScope.$apply();
      return expect(aModel2).toBe(aModel);
    });
    it("gets a model, sending appropriate parameters in the get request via httpOptions", function() {
      var Model, aModel, aModel2, httpOptions;
      httpBackend.expectGET("" + modelUrl + "/1?data=true&query=true").respond(200, modelList[0]);
      httpOptions = {
        params: {
          data: true,
          query: true
        }
      };
      Model = modelFactory(modelUrl);
      aModel = null;
      Model.get(1, false, httpOptions).then(function(m) {
        return aModel = m;
      });
      httpBackend.flush();
      httpBackend.expectGET("" + modelUrl + "/1?data=true&query=true").respond(200, modelList[0]);
      aModel2 = null;
      aModel.$get(true, httpOptions).then(function(m) {
        return aModel2 = m;
      });
      httpBackend.flush();
      return expect(aModel2).toBe(aModel);
    });
    it("gets a collection of models and stores them in the cache", function() {
      var Model, collection, collection2, index, key, model, value, _i, _len;
      httpBackend.expectGET(new RegExp("" + modelUrl + "/1")).respond(200, modelList[0]);
      httpBackend.expectGET(new RegExp("" + modelUrl)).respond(200, modelList);
      Model = modelFactory(modelUrl);
      Model.get(1);
      collection = null;
      Model.getCollection().then(function(m) {
        return collection = m;
      });
      httpBackend.flush();
      expect(collection instanceof Array).toBeTruthy();
      for (index = _i = 0, _len = collection.length; _i < _len; index = ++_i) {
        model = collection[index];
        expect(model instanceof Model).toBeTruthy();
        for (key in model) {
          value = model[key];
          if (!angular.isFunction(value)) {
            expect(value).toBe(modelList[index][key]);
            expect(angularCache.get(modelUrl).get("" + model.id)[key]).toBe(modelList[index][key]);
          }
        }
      }
      collection2 = null;
      Model.getCollection().then(function(m) {
        return collection2 = m;
      });
      rootScope.$apply();
      return expect(collection2).toBe(collection);
    });
    it("passes httpOptions along with the get request in getCollection", function() {
      var Model, collection;
      httpBackend.expectGET("" + modelUrl + "?data=true&query=true").respond(200, modelList);
      Model = modelFactory(modelUrl);
      collection = null;
      Model.getCollection(false, {
        params: {
          data: true,
          query: true
        }
      });
      return httpBackend.flush();
    });
    it("create a model and save it to the back end", function() {
      var Model, aModel, backendModel, modelData;
      backendModel = {
        id: 5,
        name: "model5"
      };
      httpBackend.expectPOST(new RegExp("" + modelUrl)).respond(200, backendModel);
      modelData = {
        name: "model5"
      };
      Model = modelFactory(modelUrl);
      aModel = null;
      Model.create(modelData).then(function(m) {
        return aModel = m;
      });
      httpBackend.flush();
      expect(aModel instanceof Model).toBeTruthy();
      expect(aModel.id).toBe(backendModel.id);
      return expect(aModel.name).toBe(backendModel.name);
    });
    it("creates a model, passing httpOptions appropriately", function() {
      var Model, backendModel, modelData;
      backendModel = {
        id: 5,
        name: "model5"
      };
      modelData = {
        name: "model5"
      };
      httpBackend.expectPOST("" + modelUrl, void 0, {
        "Authorization": "12345==",
        "Accept": "application/json, text/plain, */*",
        "Content-Type": "application/json;charset=utf-8"
      }).respond(200, backendModel);
      Model = modelFactory(modelUrl);
      Model.create(modelData, {
        headers: {
          'Authorization': '12345=='
        }
      });
      return httpBackend.flush();
    });
    it("saves an existing model to the backend using static method", function() {
      var Model, aModel, aModel2, backendModel;
      backendModel = {
        id: 5,
        name: "model5"
      };
      httpBackend.expectPUT(new RegExp("" + modelUrl + "/5")).respond(200, backendModel);
      Model = modelFactory(modelUrl);
      aModel = new Model({
        id: 5,
        name: "model5"
      });
      Model.save(aModel);
      httpBackend.flush();
      expect(aModel instanceof Model).toBeTruthy();
      expect(aModel.id).toBe(backendModel.id);
      expect(aModel.name).toBe(backendModel.name);
      httpBackend.expectPUT(new RegExp("" + modelUrl + "/5")).respond(200, backendModel);
      aModel2 = null;
      aModel.$save().then(function(m) {
        return aModel2 = m;
      });
      httpBackend.flush();
      return expect(aModel2).toBe(aModel);
    });
    it("saves an existing model, passing httpOptions appropriately", function() {
      var Model, aModel, backendModel, httpOptions;
      backendModel = {
        id: 5,
        name: "model5"
      };
      Model = modelFactory(modelUrl);
      aModel = new Model({
        id: 5,
        name: "model5"
      });
      httpBackend.expectPUT("" + modelUrl + "/5", aModel, {
        "Authorization": "12345==",
        "Accept": "application/json, text/plain, */*",
        "Content-Type": "application/json;charset=utf-8"
      }).respond(200, backendModel);
      httpOptions = {
        headers: {
          'Authorization': '12345=='
        }
      };
      Model.save(aModel, httpOptions);
      httpBackend.flush();
      httpBackend.expectPUT("" + modelUrl + "/5", aModel, {
        "Authorization": "12345==",
        "Accept": "application/json, text/plain, */*",
        "Content-Type": "application/json;charset=utf-8"
      }).respond(200, backendModel);
      aModel.$save(httpOptions);
      return httpBackend.flush();
    });
    it("should call the static method when the instance save method is called", function() {
      var Model, aModel, saveSpy;
      Model = modelFactory(modelUrl);
      aModel = new Model({
        id: 5,
        name: "model5"
      });
      saveSpy = spyOn(aModel, "$save");
      aModel.$save();
      return expect(saveSpy).toHaveBeenCalled();
    });
    it("creates a model, saves it to the backend and puts it in the cache and collection", function() {
      var Model, aModel, backendModel;
      backendModel = {
        id: 5,
        name: "model5"
      };
      httpBackend.expectPOST(new RegExp("" + modelUrl), {
        name: "model5"
      }).respond(200, backendModel);
      Model = modelFactory(modelUrl);
      aModel = null;
      Model.create({
        name: "model5"
      }).then(function(m) {
        return aModel = m;
      });
      httpBackend.flush();
      expect(aModel instanceof Model).toBeTruthy();
      expect(aModel.id).toBe(backendModel.id);
      expect(aModel.name).toBe(backendModel.name);
      return expect(angularCache.get(modelUrl).get("" + aModel.id).id).toBe(backendModel.id);
    });
    it("deletes a model and removes it from the cache and collection", function() {
      var Model, aModel, backendModel;
      backendModel = {
        id: 5,
        name: "model5"
      };
      httpBackend.expectPOST(new RegExp("" + modelUrl), {
        name: "model5"
      }).respond(200, backendModel);
      Model = modelFactory(modelUrl);
      aModel = null;
      Model.create({
        name: "model5"
      }).then(function(m) {
        return aModel = m;
      });
      httpBackend.flush();
      httpBackend.expectDELETE(new RegExp("" + modelUrl + "/5")).respond(200);
      aModel.$delete();
      return httpBackend.flush();
    });
    it("deletes a model, setting httpOptions appropriately", function() {
      var Model, aModel, backendModel, modelData;
      backendModel = {
        id: 5,
        name: "model5"
      };
      httpBackend.expectPOST(new RegExp("" + modelUrl)).respond(200, backendModel);
      modelData = {
        id: 5,
        name: "model5"
      };
      Model = modelFactory(modelUrl);
      aModel = null;
      Model.create({
        name: "model5"
      }).then(function(m) {
        return aModel = m;
      });
      httpBackend.flush();
      httpBackend.expectDELETE(new RegExp("" + modelUrl + "/5"), {
        "Authorization": "12345==",
        "Accept": "application/json, text/plain, */*"
      }).respond(200);
      Model["delete"](modelData, {
        headers: {
          'Authorization': '12345=='
        }
      });
      httpBackend.flush();
      httpBackend.expectPOST(new RegExp("" + modelUrl)).respond(200, backendModel);
      aModel = null;
      Model.create({
        name: "model5"
      }).then(function(m) {
        return aModel = m;
      });
      httpBackend.flush();
      httpBackend.expectDELETE(new RegExp("" + modelUrl + "/5"), {
        "Authorization": "12345==",
        "Accept": "application/json, text/plain, */*"
      }).respond(200);
      aModel.$delete({
        headers: {
          'Authorization': '12345=='
        }
      });
      return httpBackend.flush();
    });
    it("throws an error when the object passed to save does not have an id", function() {
      var Model, aModel;
      Model = modelFactory(modelUrl);
      aModel = {};
      return expect(function() {
        return Model.save(aModel);
      }).toThrow(new Error("Model must have an id property to be saved"));
    });
    it("throws an error when trying to create an object with an id already set", function() {
      var Model, aModel;
      Model = modelFactory(modelUrl);
      aModel = {
        id: 1
      };
      return expect(function() {
        return Model.create(aModel);
      }).toThrow(new Error("Can not create new model that already has an id set"));
    });
    it("uses the same promise while waiting for the backend to return a get request", function() {
      var Model, promise1, promise2, promise3, promise4, promise5, promise6;
      httpBackend.expectGET(new RegExp("" + modelUrl + "/1")).respond(200, modelList[0]);
      httpBackend.expectGET(new RegExp("" + modelUrl + "/2")).respond(200, modelList[1]);
      httpBackend.expectGET(new RegExp("" + modelUrl)).respond(200, modelList);
      Model = modelFactory(modelUrl);
      promise1 = Model.get(1);
      promise2 = Model.get(1);
      promise3 = Model.get(2);
      promise4 = Model.get(2);
      promise5 = Model.getCollection();
      promise6 = Model.getCollection();
      expect(promise1).toBe(promise2);
      expect(promise3).toBe(promise4);
      expect(promise5).toBe(promise6);
      return httpBackend.flush();
    });
    it("expires and refreshes or removes the object from the cache", function() {
      var Model, aModel;
      aModel = null;
      Model = modelFactory(modelUrl, {
        cacheOptions: {
          maxAge: 50,
          recycleFreq: 10,
          deleteOnExpire: 'aggresive'
        }
      });
      runs(function() {
        var newModel;
        httpBackend.expectGET(new RegExp("" + modelUrl + "/1")).respond(200, modelList[0]);
        Model.get(1).then(function(m) {
          return aModel = m;
        });
        httpBackend.flush();
        newModel = angular.copy(modelList[0]);
        newModel.name = "updated";
        return httpBackend.expectGET(new RegExp("" + modelUrl + "/1")).respond(200, newModel);
      });
      waits(150);
      runs(function() {
        var aModel2;
        httpBackend.flush();
        aModel2 = null;
        Model.get(1).then(function(m) {
          return aModel2 = m;
        });
        rootScope.$apply();
        expect(aModel2.name).toBe("updated");
        expect(aModel.id).toBe(aModel2.id);
        return httpBackend.expectGET(new RegExp("" + modelUrl + "/1")).respond(404);
      });
      waits(150);
      return runs(function() {
        var error;
        httpBackend.flush();
        httpBackend.expectGET(new RegExp("" + modelUrl + "/1")).respond(404);
        error = null;
        Model.get(1).then(null, function(e) {
          return error = e;
        });
        httpBackend.flush();
        return expect(error.status).toBe(404);
      });
    });
    it("@get returns a rejected promise in the event of an error.", function() {
      var Model, promise, rejectFunc;
      httpBackend.expectGET(new RegExp("" + modelUrl + "/1")).respond(400);
      Model = modelFactory(modelUrl);
      promise = Model.get(1);
      rejectFunc = jasmine.createSpy('rejectFunc');
      promise.then(null, rejectFunc);
      httpBackend.flush();
      rootScope.$apply();
      return expect(rejectFunc).toHaveBeenCalled();
    });
    it("@getCollection returns a rejected promise in the event of an error.", function() {
      var Model, promise, rejectFunc;
      httpBackend.expectGET(new RegExp("" + modelUrl)).respond(400);
      Model = modelFactory(modelUrl);
      promise = Model.getCollection();
      rejectFunc = jasmine.createSpy('rejectFunc');
      promise.then(null, rejectFunc);
      httpBackend.flush();
      rootScope.$apply();
      return expect(rejectFunc).toHaveBeenCalled();
    });
    it("@save returns a rejected promise in the event of an error.", function() {
      var Model, aModel, promise, rejectFunc;
      httpBackend.expectPUT(new RegExp("" + modelUrl + "/1")).respond(400);
      Model = modelFactory(modelUrl);
      aModel = new Model({
        id: 1,
        name: "model5"
      });
      promise = Model.save(aModel);
      rejectFunc = jasmine.createSpy('rejectFunc');
      promise.then(null, rejectFunc);
      httpBackend.flush();
      rootScope.$apply();
      return expect(rejectFunc).toHaveBeenCalled();
    });
    it("@create returns a rejected promise in the event of an error.", function() {
      var Model, aModel, promise, rejectFunc;
      httpBackend.expectPOST(new RegExp("" + modelUrl)).respond(400);
      Model = modelFactory(modelUrl);
      aModel = new Model({
        name: "model5"
      });
      promise = Model.create(aModel);
      rejectFunc = jasmine.createSpy('rejectFunc');
      promise.then(null, rejectFunc);
      httpBackend.flush();
      rootScope.$apply();
      return expect(rejectFunc).toHaveBeenCalled();
    });
    it("@delete returns a rejected promise in the event of an error.", function() {
      var Model, aModel, promise, rejectFunc;
      httpBackend.expectDELETE(new RegExp("" + modelUrl + "/1")).respond(400);
      Model = modelFactory(modelUrl);
      aModel = new Model({
        id: 1,
        name: "model5"
      });
      promise = Model["delete"](aModel);
      rejectFunc = jasmine.createSpy('rejectFunc');
      promise.then(null, rejectFunc);
      httpBackend.flush();
      rootScope.$apply();
      return expect(rejectFunc).toHaveBeenCalled();
    });
    it("@query properly queries the endpoint and stores the resulting models in the cache and in the _queryMap", function() {
      var Model, modelData, promise, promise2, queryResult, queryResult2;
      modelData = [
        {
          id: 1,
          name: "model5"
        }
      ];
      httpBackend.expectGET(new RegExp("" + modelUrl + "\\?name=model5")).respond(200, modelData);
      queryResult = null;
      Model = modelFactory(modelUrl);
      promise = Model.query({
        name: "model5"
      });
      promise.then(function(data) {
        return queryResult = data;
      });
      httpBackend.flush();
      rootScope.$apply();
      expect(queryResult.length).toBe(1);
      expect(queryResult[0].id).toBe(modelData[0].id);
      queryResult2 = null;
      promise2 = Model.query({
        name: "model5"
      });
      promise2.then(function(data) {
        return queryResult2 = data;
      });
      rootScope.$apply();
      return expect(queryResult2).toBe(queryResult);
    });
    it("@query returns a rejected promise in the event of an error.", function() {
      var Model, promise, rejectFunc;
      httpBackend.expectGET(new RegExp("" + modelUrl + "\\?name=model5")).respond(400);
      Model = modelFactory(modelUrl);
      promise = Model.query({
        name: "model5"
      });
      rejectFunc = jasmine.createSpy('rejectFunc');
      promise.then(null, rejectFunc);
      httpBackend.flush();
      rootScope.$apply();
      return expect(rejectFunc).toHaveBeenCalled();
    });
    it("@query properly queries the endpoint and stores the results for differnt param order", function() {
      var Model, modelData, promise, promise2, queryResult, queryResult2;
      modelData = [
        {
          id: 1,
          name: "model5",
          date: 1
        }
      ];
      httpBackend.expectGET(new RegExp("" + modelUrl + "\\?date=1&name=model5")).respond(200, modelData);
      queryResult = null;
      Model = modelFactory(modelUrl);
      promise = Model.query({
        name: "model5",
        date: 1
      });
      promise.then(function(data) {
        return queryResult = data;
      });
      httpBackend.flush();
      rootScope.$apply();
      expect(queryResult.length).toBe(1);
      expect(queryResult[0].id).toBe(modelData[0].id);
      queryResult2 = null;
      promise2 = Model.query({
        date: 1,
        name: "model5"
      });
      promise2.then(function(data) {
        return queryResult2 = data;
      });
      rootScope.$apply();
      return expect(queryResult2).toBe(queryResult);
    });
    return it("@query properly queries the endpoint and stores the results for differnt param order", function() {
      var Model, modelData, modelData2, promise, promise2, queryResult, queryResult2;
      modelData = [
        {
          id: 1,
          name: "model5"
        }
      ];
      httpBackend.expectGET(new RegExp("" + modelUrl + "\\?name=model5")).respond(200, modelData);
      queryResult = null;
      Model = modelFactory(modelUrl);
      promise = Model.query({
        name: "model5"
      });
      promise.then(function(data) {
        return queryResult = data;
      });
      httpBackend.flush();
      rootScope.$apply();
      expect(queryResult.length).toBe(1);
      expect(queryResult[0].id).toBe(modelData[0].id);
      modelData2 = [
        {
          id: 1,
          name: "model4"
        }
      ];
      httpBackend.expectGET(new RegExp("" + modelUrl + "\\?name=model5")).respond(200, modelData2);
      queryResult2 = null;
      promise2 = Model.query({
        name: "model5"
      }, true);
      promise2.then(function(data) {
        return queryResult2 = data;
      });
      httpBackend.flush();
      rootScope.$apply();
      return expect(queryResult2).toBe(queryResult);
    });
  });

}).call(this);
